# Side Effects, Reducers & Context API

## Side Effects

-   Since the main purpose of react is to render the UI and react to the user's input and manage state and props derived from that interaction using several helpers like the `useState()` hook, the side effects are the things that are happening behind the scenes, like:
    -   Storing data in the browser storage
    -   Sending http requests
    -   Managing timers
    -   Managing keyboard input that affects the state
-   React has a special hook for these tasks:

    ```JSX
    // Hook structure
    useEffect(() => {...}, [dependencies]);
    ```

    -   The first argument is a function that is executed after every dependency evaluation changes
    -   The second one is an array that has the dependencies used inside the function
        -   Add:
            -   If you want to use the effect for continuous checking, add the dependency or dependencies you want to keep an eye on inside (useful in timeouts or to check continuous events happening outside the app)
        -   Don't add:
            -   State updating functions `const [state, updateState] = useState();`
            -   If you want the effect just to be called once don't add nothing to the dependencies array
            -   Buit-in APIs functions and global variables like `fetch()` or `localStorage`
            -   Anything defined outside the component
        -   Using the `useEffect` hook without a dependencies array will make the app trigger it at any event which can make it collapse
    -   Cleanup function

        -   Sometimes we need to check for side effects at certain time, this is called debouncing and is helpful to avoid unnecessarily computation, for example using http requests or with something that changes every certain time

            ```JSX
            import React, { useState, useEffect } from 'react';

            export default function Component() {
            const [mystate, setState] = useState(0);
            // Adds 1 to state every second
            useEffect(() => {
                const addOne = setTimeout(() => {
                    setState(prevState => ++prevState);
                }, 1000);
                // Clearup function
                return () => {
                    clearTimeout(addOne);
                };
            }, [mystate]);

                return(
                    <div>{mystate}</div>
                );
            }
            ```

-   These effects are especially useful for persintency in web browsers

-   Local storage and `useEffect()`

    -   Local storage is located inside the developer tools of your browser in `Application (Chrome) | Storage (Safari) -> Local Storage -> https://your-website.urls`

    ```JSX
    import React, { useState, useEffect } from 'react';

    import Login from './components/Login/Login';
    import Home from './components/Home/Home';

    export default function App() {
        const [isLoggedIn, setIsLoggedIn] = useState(false),
            [database] = useState(dbJSONobject);

        useEffect(() => {
            const userIsLogged = localStorage.getItem('isLoggedIn');
            setIsLoggedIn(userIsLogged === '1' ? true : false);
        }, []); // No dependencies, just needed to be checked once

        const loginHandler = (email, password) => {
            // Check that password and email match
            if (database[email] === password) {
                // Set a login storage persistent value
                localStorage.setItem('isLoggedIn', '1');
                setIsLoggedIn(true);
            }
        };

        const logoutHandler = () => {
            // Clears storage for logout persistency
            localStorage.removeItem('isLoggedIn');
            setIsLoggedIn(false);
        };

        return (
            <>
                <div isAuthenticated={isLoggedIn} onLogout={logoutHandler}/>
                <main>
                    {!isLoggedIn && (
                        <Login database={database} onLogin={loginHandler} />
                    )}
                    {isLoggedIn && <Home onLogout={logoutHandler} />}
                </div>
            </>
        );
    }
    ```

## Reducers

-   Reducers mamage complex states that have several ways to be modified and are potentially error-prone if managed with `useState()`
-   They are also useful to update several values bases on previous states that are related, like several fields of a form
-   Reducers can be managed managed with the `useReducer()` hook in React

    ```JSX
    import React, { useReducer } from 'react';

    export default function Component() {
        const [mystate, dispatchFn] = useReducer(reducerFn, initialState, initFn);
        return <div></div>
    }
    ```
